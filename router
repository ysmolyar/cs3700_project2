#!/usr/bin/env python3
""" Skeleton Implementation of Project 2 for NEU CS3700 """

import argparse
import json
import select
import socket
import logging
import copy
from utils import *

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"
WAIT = "wait"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"

# string encoding
UTF8 = "utf-8"

logging.basicConfig(filename="debug.log", level=logging.DEBUG, filemode="w")


##########################################################################################

class Router:
    """ Your Router """

    def __init__(self, asn, networks):
        self.routes = {}
        self.updates = {}
        self.relations = {}
        self.sockets = {}
        self.asn = asn
        for relationship in networks:
            network, relation = relationship.split("-")
            self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation

    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        outroutes = []

        for addr in self.routes:
            for route in self.routes[addr]:
                if addr_in_range(daddr[DEST], route[NTWK], route[NMSK]):
                    cp_route = copy.deepcopy(route)
                    cp_route['peer'] = addr
                    outroutes.append(cp_route)

        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        min_asn_length = len(routes[0][APTH]) if len(routes) > 0 else 0

        for route in routes:
            min_asn_length = min(min_asn_length, len(route[APTH]))

        for route in routes:
            if len(route[APTH]) == min_asn_length:
                outroutes.append(route)

        return outroutes

    def get_highest_preference(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        max_pref = routes[0][LPRF]
        for route in routes:
            max_pref = max(max_pref, route[LPRF])

        for route in routes:
            if route[LPRF] == max_pref:
                outroutes.append(route)

        # print("get_highest_preference: " + str(outroutes) + "\n")
        return outroutes

    def get_self_origin(self, routes):
        """ select self originating routes """
        # TODO
        outroutes = []

        if len(routes) <= 1 or not any(route[SORG] == True for route in routes):
            outroutes = routes

        if any(route[SORG] == True for route in routes):
            outroutes = [route for route in routes if route[SORG] == True]

        # print("get_self_origin: " + str(outroutes) + "\n")
        return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: IGP > EGP > UNK """
        # TODO
        outroutes = []

        for route in routes:
            if route[ORIG] == 'IGP':
                outroutes.append(route)

        if len(outroutes) == 0:
            for route in routes:
                if route[ORIG] == 'EGP':
                    outroutes.append(route)

        if len(outroutes) == 0:
            for route in routes:
                if route[ORIG] == 'UNK':
                    outroutes.append(route)

        # print("get_origin_routes: " + str(outroutes) + "\n")
        return outroutes

    def lowest_ip_address(self, routes):

        outroutes = []
        lowest_address = routes[0][PEER].split('.')[0] if len(routes) > 0 else 0
        for route in routes:
            word = route[PEER].split('.')[0]
            lowest_address = lowest_address if lowest_address < word else word

        for route in routes:
            word = route[PEER].split('.')[0]
            if word == lowest_address:
                outroutes.append(route)

        # print("lowest_ip_address: " + str(outroutes) + "\n")
        return outroutes

    def get_longest_prefix(self, routes):
        if len(routes) == 0:
            return None

        max_pref = get_cidr_number(routes[0][NMSK])

        for route in routes:
            pref = get_cidr_number(route[NMSK])
            max_pref = max_pref if max_pref > pref else pref

        for route in routes:
            pref = get_cidr_number(route[NMSK])
            if pref == max_pref:
                return route

        return None
        # print("get_longest_prefix: " + str(outroutes) + "\n")

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        if self.relations[srcif] == CUST:
            outroutes = routes
        elif self.relations[srcif] == PEER:
            for route in routes: 
                if self.relations[route[PEER]] == CUST:
                    outroutes.append(route)
        else:
            for route in routes:
                if self.relations[route[PEER]] != PEER:
                    outroutes.append(route)

        # print("filter_relationships: " + str(outroutes) + "\n")
        return outroutes

    def get_route(self, srcif, daddr):
        """
        Select the best route for a given address. Determine:
            (1) which route (if any) in the forwarding table is the best route to use for the given destination IP
            (2) whether the data packet is being forwarded legally
        """
        peer = None
        initial_routes = self.lookup_routes(daddr)
        # print("INITIAL ROUTES: " + str(initial_routes) + "\n")
        # print("CONSIDERING SENDING DATA PACKET: " + str(daddr) + "\n")
        if len(initial_routes) == 0:
            packet = {'src': daddr[DEST], 'dst': srcif, 'type': NRTE, 'msg': {}}
            self.sockets[srcif].sendall(json.dumps(packet).encode(UTF8))

        # Rules go here
        else:
            # 1. Highest Preference
            routes = self.get_highest_preference(initial_routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. EGP > IGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            routes = self.lowest_ip_address(routes)
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)
            # In case of multiple routes, longest prefix wins
            route = self.get_longest_prefix(routes)
            # print("MY TABLE: " + str(self.routes) + "\n")
            # print("FINAL ROUTES: " + str(routes) + "\n")
            # print("srcif: " + str(srcif) + "\n")
            # print("data packet: " + str(daddr) + "\n")
            if route is None:
                packet = {'src': get_self_ip(srcif), 'dst': daddr[SRCE], 'type': NRTE, 'msg': {}}
                # print("****sending no route: " + str(packet) + "\n")
                self.sockets[srcif].sendall(json.dumps(packet).encode(UTF8))
            else:
                # print("****sending data packet: " + str(daddr) + " to " + srcif + "\n")
                self.sockets[route[PEER]].sendall(json.dumps(daddr).encode(UTF8))

        return self.sockets[peer] if peer else None

    def forward(self, srcif, packet):
        """ Forward a data packet """

        # TODO
        return False

    def can_coalesce(self, route_1, route_2):
        """
        Determines if routes can be coalesced. Routes can be coalesced if:
            (1) adjacent numerically
            (2) forward to the same next-hop router
            (3) have the same attributes
        Condition 2 is already satisfied by the structure of the forwarding table.
        :param route_1: route 1
        :param route_2: route 2
        :return: True or False; whether or not routes can coalesce
        """
        mask_length = get_cidr_number(route_1[NMSK])

        adjacent = (get_cidr_number(route_1[NMSK]) == get_cidr_number(route_2[NMSK]) and
                    get_subnet(route_1[NTWK], route_1[NMSK]) != get_subnet(route_2[NTWK], route_2[NMSK]) and
                    addr_to_binary(route_1[NTWK])[:mask_length-1] == addr_to_binary(route_2[NTWK])[:mask_length-1])

        same_attributes = (route_1[LPRF] == route_2[LPRF] and
                           route_1[SORG] == route_2[SORG] and
                           route_1[APTH] == route_2[APTH] and
                           route_1[ORIG] == route_2[ORIG])
        return adjacent and same_attributes

    def coalesce(self, new_route):
        """
        coalesce any routes that are right next to each other:
        """
        if new_route not in self.routes[new_route[PEER]]:
            self.routes[new_route[PEER]].append(new_route)

        for route in self.routes[new_route[PEER]]:
            if self.can_coalesce(route, new_route):
                self.routes[new_route[PEER]].remove(new_route)
                new_network = binary_to_addr(bin(int(addr_to_binary(route[NTWK]), 2) &
                                                 int(addr_to_binary(route[NMSK]), 2))[2:])
                comb_route = {
                    NTWK: new_network,
                    NMSK: decrement_mask(route[NMSK]),
                    LPRF: route[LPRF],
                    APTH: route[APTH],
                    ORIG: route[ORIG],
                    SORG: route[SORG],
                    PEER: route[PEER]
                }

                self.routes[new_route[PEER]].remove(route)
                self.routes[new_route[PEER]].append(comb_route)
                self.coalesce(comb_route)

        return False

    def create_update_packet(self, packet, dest):
        """update packet src, dest, ASPath, and return updated packet"""
        packet_cpy = self.create_revk_packet(packet, dest)
        packet_cpy[MESG][APTH].append(self.asn)
        return packet_cpy

    def create_revk_packet(self, packet, dest):
        """update packet src, dest, and return updated packet"""
        packet_cpy = copy.deepcopy(packet)
        packet_cpy[SRCE] = dest[:-1] + '1'
        packet_cpy[DEST] = dest
        return packet_cpy

    def update(self, srcif, packet):
        """
        handle update packets:
            (1) save a copy of the announcement in case you need it later
            (2) add an entry to your forwarding table
            (3) potentially send copies of the announcement to neighboring routers
                - if Update received from a customer: send updates to all other neighbors
                - if Update received from a peer or a provider: only send updates to your customers
        """
        msg = copy.deepcopy(packet)
        msg[MESG][PEER] = srcif
        # (1)
        if packet[SRCE] not in self.updates:
            self.updates[packet[SRCE]] = []

        self.updates[packet[SRCE]].append(msg)

        # (2)
        if srcif not in self.routes:
            self.routes[srcif] = []

        self.coalesce(msg[MESG])
        # (3)
        if self.relations[srcif] == CUST:
            for addr, sock in self.sockets.items():
                if addr != srcif:
                    new_packet = self.create_update_packet(packet, addr)
                    sock.sendall(json.dumps(new_packet).encode(UTF8))
        else:
            for addr, sock in self.sockets.items():
                if addr != srcif and self.relations[addr] == CUST:
                    new_packet = self.create_update_packet(packet, addr)
                    sock.sendall(json.dumps(new_packet).encode(UTF8))

        return False

    def revoke(self, srcif, packet):
        """
        handle revoke packets:
            (1) save a copy of the revocation, in case you need it later
            (2) remove the dead entry from the forwarding table
            (3) potentially send copies of the announcement to neighboring routers
        """
        # (1)
        print("table before revoke")
        print(self.routes)
        print()
        print()
        if packet[SRCE] not in self.updates:
            self.updates[packet[SRCE]] = []

        self.updates[packet[SRCE]].append(packet);

        # (2)
        new_updates = []
        # print("updates")
        # print(self.updates)
        for update in self.updates[packet[SRCE]]:
            if update[TYPE] == 'update':
                new_updates.append(update)
            elif update[TYPE] == 'revoke':
                for msg in update[MESG]:
                    for upd in new_updates:
                        # print("revoke")
                        # print(upd)
                        if upd[MESG][NTWK] == msg[NTWK] and upd[MESG][NMSK] == msg[NMSK]:
                            new_updates.remove(upd)

        self.routes[srcif] = []
        for update in new_updates:
            self.coalesce(update[MESG])

        # (3)
        if self.relations[srcif] == CUST:
            for addr, sock in self.sockets.items():
                if addr != srcif:
                    new_packet = self.create_revk_packet(packet, addr)
                    sock.sendall(json.dumps(new_packet).encode(UTF8))
        else:
            for addr, sock in self.sockets.items():
                if addr != srcif and self.relations[addr] == CUST:
                    new_packet = self.create_revk_packet(packet, addr)
                    sock.sendall(json.dumps(new_packet).encode(UTF8))

        return True

    def dump(self, packet):
        """ handles dump table requests """
        dump_packet = copy.deepcopy(packet)
        dest = dump_packet[SRCE]
        dump_packet[SRCE] = dest[:-1] + '1'
        dump_packet[DEST] = dest
        dump_packet[TYPE] = 'table'
        fwd = []
        for src in self.routes:
            for route in self.routes[src]:
                fwd.append({'network': route[NTWK], 'netmask': route[NMSK], 'peer': route['peer']})
        dump_packet[MESG] = fwd

        self.sockets[dump_packet[DEST]].sendall(json.dumps(dump_packet).encode(UTF8))
        return True

    def no_route(self, srcif, packet):
        """ sends no route message  """
        # TODO
        return False

    def handle_packet(self, srcif, packet):
        """ dispatches a packet """
        if packet["type"] == WAIT:
            pass
        elif packet["type"] == UPDT:
            self.update(srcif, packet)
        elif packet["type"] == DATA:
            self.get_route(srcif, packet)
        elif packet["type"] == DUMP:
            self.dump(packet)
        elif packet["type"] == RVKE:
            self.revoke(srcif, packet)
        elif packet["type"] == NRTE:
            self.no_route(srcif, packet)

        return False

    def send_error(self, conn, msg):
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        """ main loop for the router """
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            srcif = sock
                    msg = json.loads(k)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return


if __name__ == "__main__":
    PARSER = argparse.ArgumentParser(description='route packets')
    PARSER.add_argument('asn', type=int, metavar="<asn>",
                        help="The autonomous system number of the router")
    PARSER.add_argument('networks', metavar="<ip_address>-<peer|prov|cust>", type=str, nargs="+",
                        help="The IP address and relationship with a neighboring router")
    ARGS = PARSER.parse_args()
    Router(ARGS.asn, ARGS.networks).run()
